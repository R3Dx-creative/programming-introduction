# 4-3.課題.ファイル操作 の解答例

## 共通

```ruby
require 'fileutils'
require 'date'
```

* https://docs.ruby-lang.org/ja/latest/class/Dir.html
* https://docs.ruby-lang.org/ja/latest/class/Date.html
* https://docs.ruby-lang.org/ja/latest/class/FileUtils.html

## 問1

```ruby
def move_file(src_folder, dest_folder)
  # src_folder配下のファイルをdest_folderに移動
  Dir.each_child(src_folder) do |file|
    FileUtils.move("#{src_folder}/#{file}", dest_folder)
  end
end
move_file("0.Shared", "1.Queue")
```

## 問2

```ruby

def ranked_dir(date)
  # 任意の日付(Date型)のファイル名(Ranked.yyyy-MM-dd)を作成
  date_str = date.strftime("%Y-%m-%d")
  "Ranked.#{date}"
end
FileUtils.mkdir(ranked_dir(Date.today))
```

## 問3

```ruby
# 基準
BORDER = 5

# 集計結果
result = {
  "0.txt" => 0,
  "1.txt" => 5,
  "2.txt" => 5,
  "3.txt" => 6,
  "4.txt" => 7,
  "5.txt" => 5,
  "6.txt" => 1
}

# ランク外かの判定
def unranked?(like)
  like < BORDER
end

# 仕分け(集計元, 集計結果)
def classify(src, result)
  Dir.each_child(src) do |file|
    if unranked?(result[file])
      FileUtils.move("#{src}/#{file}", "3.Unranked")
    elsif
      FileUtils.move("#{src}/#{file}", "2.Revenging")
    end
  end
end
classify("1.Queue", result)
```

## 問3(クラス使用バージョン)
```ruby
# クラス使用バージョン
class Clip
  attr_reader :file, :like

  def initialize(file, like)
    @file = file
    @like = like
  end

  def unranked?
    @like < BORDER
  end

  def self.clips(src, result)
    Dir.each_child(src).map { |file| Clip.new("#{src}/#{file}", result[file]) }
  end
end

def classify_clips(src, result)
  Clip.clips(src, result).each do |clip|
    if clip.unranked?
      FileUtils.move(clip.file, "3.Unranked")
    elsif
      FileUtils.move(clip.file, "2.Revenging")
    end
  end
end
classify_clips("1.Queue", result)
```

## 問4

```ruby
def classify_clips_for_rank(src, result)
  # ソート(likeの降順, fileの昇順)
  sorted_clips = Clip.clips(src, result).sort { |a, b| 
    [-a.like, a.file] <=> [-b.like, b.file]
  }

  # 今日のランキングフォルダ
  today_dir = ranked_dir(Date.today)
  if !Dir.exist?(today_dir)
    FileUtils.mkdir(today_dir)
  end

  # トップ3を格納
  sorted_clips[0...3].each do |clip|
    FileUtils.move(clip.file, today_dir)
  end

  # その他の仕分け
  n = sorted_clips.size
  sorted_clips[3...n].each do |clip|
    if clip.unranked?
      FileUtils.move(clip.file, "3.Unranked")
    elsif
      FileUtils.move(clip.file, "2.Revenging")
    end
  end
end
classify_clips_for_rank("1.Queue", result)
```

## 問5

```ruby
# ==-- 問5 --==
def classify_clips_for_rank_with_revenge(srcs, result)
    # ソート(likeの降順, fileの昇順)
    sorted_clips = srcs
    .map{ |src| Clip.clips(src, result) }
    .flatten
    .sort { |a, b| 
      [-a.like, a.file] <=> [-b.like, b.file]
    }
  
    # 今日のランキングフォルダ
    today_dir = ranked_dir(Date.today)
    if !Dir.exist?(today_dir)
      FileUtils.mkdir(today_dir)
    end
  
    # トップ3を格納
    sorted_clips[0...3].each do |clip|
      FileUtils.move(clip.file, today_dir)
    end
  
    # その他の仕分け
    n = sorted_clips.size
    sorted_clips[3...n].each do |clip|
      if clip.unranked?
        FileUtils.move(clip.file, "3.Unranked")
      elsif
        begin
          FileUtils.move(clip.file, "2.Revenging")
        rescue => error
          puts "same file"
        end
      end
    end
end

classify_clips_for_rank_with_revenge(["1.Queue", "2.Revenging"], result)
```

---

## TODO

Clipクラスに元のフォルダ情報を保持する必要ありかも。あとファイルを移動するmoveメソッドを入れてもいい気もする。

いいね数をもとに仕分け先フォルダを返すメソッドがあると良いと思う。もしくは仕分け用のクラス(`ClipClassifier`的な)

